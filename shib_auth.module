<?php
// $Id$
/**
 * @file
 * This is a Shibboleth authentication module.
 *
 * This module allow administrators to enable Shibboleth based authentication on their drupal installation.
 */

/** 
 * We should insert some DISCLAIMER here, what do you think?
 */

/** 
 * Shibboleth authentication module configuration
 * 
 * @return array containing configuration
 */
function shib_auth_get_config () {
  global $base_url;
  // Q: This method will disable using function-specific default value, need to check if we use it somewhere
  $config = array();
  $config['auth_link_text'] = variable_get('auth_link_text', t('Shibboleth Login'));
  $config['account_linking'] = variable_get('shib_auth_account_linking', FALSE);
  $config['destroy_session'] = variable_get('shib_auth_auto_destroy_session', FALSE);
  $config['debug'] = variable_get('shib_auth_debug_state', FALSE);
  $config['debug_url'] = variable_get('shib_auth_debug_url', '');
  $config['override_username'] = variable_get('shib_auth_define_username', FALSE);
  $config['override_email'] = variable_get('shib_auth_enable_custom_mail', FALSE);
  $config['forceauthn'] = variable_get('shib_auth_forceauthn', FALSE);
  $config['handler_protocol'] = variable_get('shib_auth_handler_protocol', "https");
  $config['handler_url'] = variable_get('shib_auth_handler_url', "/Shibboleth.sso");
  $config['shib_auth_force_https'] = variable_get('shib_auth_force_https', FALSE);
  $config['ispassive'] = variable_get('shib_auth_is_passive', FALSE);
  $config['req_consent'] = variable_get('shib_auth_terms_accept', FALSE);
  $config['terms_ver'] = variable_get('shib_auth_terms_ver', '');
  $config['email_variable'] = variable_get('shib_auth_username_email', "HTTP_SHIB_MAIL");
  $config['username_variable'] = variable_get('shib_auth_username_variable', "REMOTE_USER");
  $config['wayf_location'] = variable_get('shib_auth_wayf_uri', "/DS");
  $config['logout_return'] = variable_get('shib_logout_url', $base_url);
  // XXX where do we use these values?
  // A: Now, I know what are we talking about here. Did you just rename full_handler/logout_url variables to these?
	/*
  $config['session_initiator'] = variable_get('shib_session_initiator', shib_auth_get_handler_base()."/Login");
  $config['logout_initiator'] = variable_get('shib_logout_initiator', 
	(isset ($_SERVER["HTTP_SHIB_SHIBLOGOUT"] ) ? $_SERVER["HTTP_SHIB_SHIBLOGOUT"] 
						   : shib_auth_get_handler_base()."/Logout"));
	*/
	//They were named and meant to be used like these (see forms.inc) Should we rename them to sg else?
 	$config['full_handler_url'] = variable_get('shib_auth_full_handler_url', shib_auth_get_handler_base(). variable_get('shib_auth_wayf_uri', '/DS'));
	$config['full_logout_url'] = variable_get('shib_auth_full_logout_url', shib_auth_get_handler_base() ."/Logout");
 
  //advanced features
	
  $config['destroy_session'] = variable_get('shib_auth_auto_destroy_session', FALSE);
  $config['forceauthn'] = variable_get('shib_auth_forceauthn', FALSE);
  $config['ispassive'] = variable_get('shib_auth_is_passive', FALSE);
  $config['req_consent'] = variable_get('shib_auth_terms_accept', FALSE);
  $config['shib_auth_terms_url'] = variable_get('shib_auth_terms_url', '/');
  $config['terms_ver'] = variable_get('shib_auth_terms_ver', '');
  $config['logout_return'] = variable_get('shib_logout_url', $base_url);
 
  return $config;
}

/**
 * This footer part executes isPassive script, if the option was checked on the configuration page
 */
function shib_auth_footer() {
  global $user, $shib_auth_config;

  if (!shib_auth_session_valid() && $shib_auth_config['ispassive'] && !$user->uid) {
    $base = drupal_get_path('module', 'shib_auth');
    //TODO
    //A lot of parameterizing stuff, the script is pretty general now, the urls need to be generated based on handler/wayf/login/logout configs
    //Any1 good at that? ;)
    $my_settings = array( 'login_url' => shib_auth_generate_login_url());
    drupal_add_js(array('shib_auth' => $my_settings), "setting");
    drupal_add_js($base.'/isPassive.js','module','footer');
  }
}




/**
 * Display help and module information
 * @param path which path of the site we're displaying help
 * @param arg array that holds the current path as would be returned from arg() function
 * @return help text for the path
 */
function shib_auth_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/help#shib_auth':
      //TODO
      $output ='<p>'. t("The Shibboleth authentication module lets you utilize the advantages of the "
		    . "Single Sign On (SSO) methods.") .'</p>';
      $output .='<p>'. t("For more help related to Shibboleth and module configuration, see "
		     . "<a href=\"@wiki\">NIIF AAI wiki pages</a>.",
			array('@wiki' => url('https://wiki.aai.niif.hu/index.php/Drupal_Shibboleth_module'))) .'</p>';

      break;
    case 'admin/user/shib_auth':
      $output = '<p>'. t("The text shown in the block and on other login pages can be changed on the "
		     . "<a href=\"@block\">block settings page</a>.",
			array('@block' => url('admin/build/block/configure/shib_auth/0'))) .'</p>';
      break;
  }
  return $output;
} // function shib_auth_help

/** Errors out
  * Example usage:
  * 	if (something_bad_happens())
  *		return shib_auth_error("Something bad happened");
	* EXEPTION WORKAROUND for php4
  * A: I wouldn't use return, because there could be cases, when the error doesn't exists from function / statement
  *    This need to be checked though, because in other cases, it would delete an 'else'
  */
function shib_auth_error($msg = '') {
  drupal_set_message(t($msg) . t(' [Shibboleth authentication]'),'error');
  return FALSE;
}

function shib_auth_terminate_session() {
  global $user;
  // unset all session variables and destroy session
  if (isset($user->uid))
    sess_destroy_uid($user->uid);
  $_SESSION = array();
  session_destroy();
  $user = drupal_anonymous_user();
}

function shib_auth_session_check($uname) {
  global $user;
  global $shib_auth_config;
  // if the user IS logged in as non-admin, but we're missing Shibboleth identity
  if (!shib_auth_session_valid() && $_SESSION['authentication'] == 'shib_auth' &&
      $shib_auth_config['destroy_session'] && $user->uid > 1) {
    shib_auth_error('Your session is expired. Please log in again');
    shib_auth_terminate_session();
  }
  if (isset($_SESSION['uname'])) {
    if ($_SESSION['uname'] != $uname) {
      /* XXX
	  This case another user was logged in using the same browser (and Drupal) session.
	  Probably we should try and re-register the user instead of just kicking him out,
	  but for now just terminate the session for safety.
	  This means that the new user has to initiate the session twice.
	  */
      shib_auth_terminate_session();
    }
  }
}

/**
 * Function to determine whether the called page is in the debug path
 * print_r-s $_SERVER if yes 
 */
function shib_auth_debug() {
  global $shib_auth_config;
  global $user;
  
  if ($shib_auth_config['debug'])
    if (drupal_substr($_GET['q'], 0, drupal_strlen($shib_auth_config['debug_url'])) == $shib_auth_config['debug_url']) {
      if ($user->uid) {
	$userinfo = array (
	  'uid' => $user->uid,
	  'name' => $user->name,
	  'mail' => $user->mail,
	  'roles' => $user->roles
	  );
	$debug_message = print_r ($userinfo, TRUE);
	drupal_set_message('<pre>'. $debug_message .'</pre>');
      }
      $debug_message = print_r($_SERVER, TRUE);
      drupal_set_message('<pre>'. $debug_message .'</pre>');
      
    }
}

function shib_auth_get_idp() {
  if (isset ($_SERVER['Shib-Identity-Provider']))
    return $_SERVER['Shib-Identity-Provider'];
  elseif (isset ($_SERVER['Shib_Identity_Provider']))
    return $_SERVER['Shib_Identity_Provider'];
  return $_SERVER['HTTP_SHIB_IDENTITY_PROVIDER'];
}

/**
 * Adds a record to {shib_authmap}
 *
 * @param $uid Drupal uid (number)
 * @param $federated_id federated identifier (max. 255 characters)
 * @param $consentver='' accepted terms&conditions version
 * @return FALSE on error, TRUE otherwise
 */
function shib_auth_add_authmap($uid,$federated_id,$consentver='') {
  // Check if $federated_id exists in {shib_authmap}
  $query_fed_id = db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $federated_id );
  if (db_fetch_object($query_fed_id)) {
    return shib_auth_error("Cannot link federated login to multiple accounts");
  }
  $sql="INSERT INTO {shib_authmap} (uid, targeted_id, idp, created, consentver) " 
      ."VALUES  ('%s', '%s', '%s', '%s', '%s')";
  return db_query($sql, $uid, $federated_id, shib_auth_get_idp(), date("Y-m-d H:i:s"), $consentver); 
}

/**
 * Checks whether Shibboleth SP has set the Identity Provider $_SERVER field. It is always set
 * if there is a Shibboleth SP session.
 * @return true if there is a valid Shibboleth session
 */
function shib_auth_session_valid() {
  return ((shib_auth_get_idp()));
}

/**
 * @return true if there is a valid Shibboleth session with a Shibboleth SP >= 2.0
 */
function shib_auth_session_isShib2x() {
  if (shib_auth_session_valid())
    return (isset($_SERVER['Shib-Identity-Provider']) || isset ($_SERVER['Shib_Identity_Provider']));
  return false;
}

/** 
 * Handle account linking
 * 
 * Saves an entry to {shib_authmap}, if the user is already logged in.
 * Mapping to default Drupal users (uid<=1) is not allowed.
 * @return TRUE if account linking is stored, FALSE otherwise
 */
function shib_auth_link_account ($federated_id,$consentver='') {
  global $shib_auth_config;
  global $user;
  
  // Assert some basic security requirements
  if (!$user) 
    return shib_auth_error("You must be logged in for account linking");
  if ($user->uid <= 1)
    return shib_auth_error("It is not allowed to link federated login to a system account");
  
  if ($shib_auth_config['account_linking']) 
    return shib_auth_add_authmap($user->uid,$federated_id,$consentver);
  
  return FALSE;
}

/**
 * TODO: implement
 * Creates <b>new</b> Drupal user and saves user mapping to the shib_authmap table
 * 
 * It doesn't do any check on the input parameters except for asserting uniqueness
 * 
 * @param $fed_id federated user identifier
 * @param $uname custom username (might be equal to $uid)
 * @param $mail user email address (might be user defined)
 * @param $consentver accepted version of terms&conditions (acceptance must be checked before)
 * @return TRUE if saving user was successful, FALSE otherwise
 */
function shib_auth_user_register ($fed_id,$uname,$mail,$consentver='') {
  global $user;
  
  // Ensure that we have a valid shib session
  if (!shib_auth_session_valid())
    return shib_auth_error("Internal error while saving account: missing Shibboleth session");
  
  // XXX szerintem az ellenorzes nem kell ide.
  // A: AFAIR These are here to avoid logging in an existing user with the same name instead of the creating one (because of the use of login_register func)
  /*
  // Ensure that $uname is not in use
  if ( db_fetch_object( db_query("SELECT * FROM {users} WHERE name='%s'", $uname) ) ) 
    return shib_auth_error("Error saving user account, username is already in use.");
  
  // Ensure that $mail is not in use
  if ( db_fetch_object( db_query("SELECT * FROM {users} WHERE mail='%s'", $mail) ) ) 
    return shib_auth_error("Error saving user account, email address is already in use.");
  */
  $_SESSION['authentication'] = 'shib_auth';
  // Try to load user
  $user = user_load(array('name' => $uname));
  if (!isset($user->uid)) { // New user
    $user = user_external_login_register($uname, "shib_auth");
    $user = user_save($user, array('mail' => $mail));
    return shib_auth_save_authmap($fed_id,$user->uid,$consentver);
  }
  return TRUE;
}

/**
 * Saves an authmap entry to the database. Only checks the uniqueness of the federated id
 * @return TRUE if successful
 */
function shib_auth_authmap_save($fed_id,$uid,$consentver) {
  // Check $fed_id uniqueness
  if ( db_fetch_object( db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $fed_id) ) )
    return shib_auth_error("Internal error while saving user account: federated id is not unique.");
    
  // Grab $idp from the environment, set date
  if(!shib_auth_session_valid())
    return shib_auth_error("Internal error while saving account: missing Shibboleth session");
  // save user
  $sql = "INSERT INTO {shib_authmap} (uid, targeted_id, idp, created, consentver) VALUES  ('%s', '%s', '%s', '%s', '%s')";
  return db_query($sql,	$uid, $fed_id, shib_auth_get_idp(), date("Y-m-d H:i:s"), $consentver);
}

function shib_auth_authmap_get_user ($fed_id) {
  return ( db_fetch_object( db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $fed_id) ) );
}
/**
 * TODO: remove -- CAN BE REMOVED
 * XXX
 * refactor: shib_login_save_authmap -> shib_auth_register_user ???
 * Yes, we should merge these two functions into one, but these are not the same 
 * authmap_save is only for this module, while login_register is doing it in drupal.
 */
function shib_auth_save_authmap($uname, $custom_uname, $umail_single) {
  global $user;
  $email_already_used_query = db_query("SELECT * FROM {users} WHERE mail='%s'", $umail_single );
  $email_already_used = db_fetch_object($email_already_used_query);
  // If the mail address is used, give an error
  if ($email_already_used) {
    shib_auth_error("Error saving user account. E-mail address is already used.");
  }
  //else register the user with the given information
  else {
    //account linking: the user is already logged in
    if (!($user->uid > 1 && variable_get('shib_auth_account_linking', FALSE))) {
      user_external_login_register($custom_uname, "shib_auth");
    }
    $_SESSION['authentication'] = 'shib_auth';
    $user = user_save($user, array('mail' => $umail_single));
    $idp = ($_SERVER['Shib-Identity-Provider']) ? 
      $_SERVER['Shib-Identity-Provider'] : $_SERVER['HTTP_SHIB_IDENTITY_PROVIDER'];
    $sql="INSERT INTO {shib_authmap} (uid, targeted_id, idp, created, consentver) VALUES  ('%s', '%s', '%s', '%s', '%s')";
    $result = db_query($sql, $user->uid, $uname, $idp, date("Y-m-d H:i:s"), variable_get('shib_auth_terms_ver', ''));
  }
}

/**
 * TODO: remove
*/
function shib_login_authmap($uname, $umail_single, $uid) {
  global $user;
  $auth_map_un_query = db_query("SELECT name FROM {users} WHERE uid='%s'", $uid);
  $authmap_username = db_fetch_array($auth_map_un_query);
  user_external_login_register($authmap_username['name'], "shib_auth");
  $_SESSION['authentication'] = 'shib_auth';
  //and the Shibboleth mail address override was enabled in the admin config
  if (variable_get('shib_auth_enable_custom_mail', 0)==0) {
    //check if there isn't any user with this e-mail (whose name is different)
    $email_for_other_user_query =
      db_query("SELECT * FROM {users} WHERE mail='%s' AND name <> '%s'", $umail_single, $uname );
    $email_for_other_user = db_fetch_object($username_and_email_query);
    if ($email_for_other_user) {
      shib_auth_error("Error saving user account. E-mail address is already used.");
    }
    //if everything is allright, modify the mail address of the user.
    else {
      $user = user_save($user, array('mail' => $umail_single));
    }
  }
  if (isset($_SESSION['redirected_to_custom_data_form_url'])) {
    $redirect_url = $_SESSION['redirected_to_custom_data_form_url'];
    unset($_SESSION['redirected_to_custom_data_form_url']);
    drupal_goto($redirect_url);
  }
}

/** 
 * Check user identifier 
 * @return FALSE if the identifier is not valid
 */
function shib_auth_check_identifier($uname) {
  if (!$uname) {
        $message = t('Username is missing. Please contact your site administrator!');
        shib_auth_error($message);
        watchdog('shib_auth', $message, WATCHDOG_CRITICAL);
	return FALSE;
  } else if (drupal_strlen($uname)>255) {
        $message = t('User identifier is too long to process. Please contact your site administrator!');
        shib_auth_error($message);
        watchdog('shib_auth', $message, WATCHDOG_CRITICAL);
	return FALSE;
  }
	return TRUE;
}

/**
 * Load an authmap user object from shib_authmap
 * @return the authmap object(array) if found, null otherwise
 */
function shib_auth_load_from_authmap($uname) {
  $auth_map_query = db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $uname);
  return db_fetch_array($auth_map_query); 
}

/**
 * If any customization or consent option is checked, the custom form will show up before registering.
 * 
 */
function shib_auth_custom_form($umail_single, $uname) {
  global $shib_auth_config;
    if ($shib_auth_config['override_email'] || 
				($umail_single && $shib_auth_config['override_username']) ||
				$shib_auth_config['req_consent']) {
            // if custom something was enabled on the admin form, save it as a variable
            if ($_POST['form_id'] == 'shib_auth_custom_form') {
							if ($_POST['custom_mail'])			$custom_mail = $_POST['custom_mail'];
							if ($_POST['custom_username']) 	$custom_username = $_POST['custom_username'];
							if ($_POST['accept'])           $consent_accepted = $_POST['accept'];
						}
// ****** CUSTOM MAIL **********
              //if the user provided the custom mail string on the custom data form, and it is not empty
            if (isset($custom_mail) && $custom_mail) {
              if (($consent_accepted && $shib_auth_config['req_consent']) ||
									!$shib_auth_config['req_consent']) {
		if (!valid_email_address($custom_mail)) {
		  shib_auth_error("Please enter a valid e-mail address");
		}
		// if custom username not enabled
		else if (variable_get('shib_auth_define_username', 0)==0)  {
		  // and email isn't used by another registered drupal user
		    shib_login_save_authmap($uname, $uname, $custom_mail);
		}
		//if the username is also enabled
		else if ((variable_get('shib_auth_define_username', 0)==1)&&isset($custom_username) && $custom_username) {
		  if ($error = user_validate_name($custom_username)) 
		    shib_auth_error($error);
		  else {
		    // and it isn't used by another registered drupal user
                $un_already_used_query = db_query("SELECT * FROM {users} WHERE name='%s'", $custom_username);
                $un_already_used = db_fetch_object($un_already_used_query);
                if ($un_already_used) {
                  shib_auth_error("Error saving user account. User name is already used.");
                }
                //register the user with the given address, and the shib provided username
                else {
                  shib_login_save_authmap($uname, $custom_username, $custom_mail);
                }
              }
            }
           } else shib_auth_error("You have to accept Terms and conditions to proceed");
          }

// ****** CUSTOM USERNAME **********
          //if there is no custom email option, but the user can define custom username
          else if ($shib_auth_config['override_username'] && isset($custom_username) && $custom_username)        {
          if (($consent_accepted && $shib_auth_config['req_consent']) || !$shib_auth_config['req_consent']) {
          //validate it
            if ($error = user_validate_name($custom_username)) 
              shib_auth_error($error);
            else {
              $un_already_used_query = db_query("SELECT * FROM {users} WHERE name='%s'", $custom_username);
              $un_already_used = db_fetch_object($un_already_used_query);
              if ($un_already_used) {
                shib_auth_error("Error saving user account. User name is already used.");
              }
              //register the user with the given username, and the shib provided e-mail address
              else {
                  shib_login_save_authmap($uname, $custom_username, $umail_single);
                }
            }
          }
          else shib_auth_error("You have to accept Terms and conditions to proceed");
          }
// ****** USER CONSENT **********
          else if (isset($consent_accepted) && $consent_accepted && $shib_auth_config['req_consent']) {          
              shib_login_save_authmap($uname, $uname, $umail_single);
          }
// ****** SHOW FORM, AND REDIRECT ********
          //We want to show the custom mail input form, and then redirect the user to the node, he wanted to go
          else if ($_GET['q']!='shib_auth/get_custom_data') {
          
							$_SESSION['redirected_to_custom_data_form'] = TRUE;
              $_SESSION['redirected_to_custom_data_form_url'] = $_GET['q'];
							drupal_goto('shib_auth/get_custom_data'); 
          }
          
            //then the user is redirected to the page, which she wanted to open before the auth process had been initiatedd
            
           if (isset($_SESSION['redirected_to_custom_data_form_url'])) {
              $redirect_url = $_SESSION['redirected_to_custom_data_form_url'];
              unset($_SESSION['redirected_to_custom_data_form_url']);
              drupal_goto($redirect_url); 
            }
        }
}

function doing_account_linking() {
//TODO: rename this function
  global $shib_auth_config;
  if ($shib_auth_config['account_linking'])
    return (strstr($_GET['q'],"shib_login") || strstr($_GET['q'],"shib_auth_custom_form"));
  return FALSE;
}

function shib_auth_consent_update($uname, $umail_single, $uid) {
	global $shib_auth_config;
	$sql="UPDATE {shib_authmap} SET consentver='%s' WHERE targeted_id='%s'";
  $result = db_query($sql, $shib_auth_config['terms_ver'], $uname);
  shib_login_authmap($uname, $umail_single, $uid);
}
/**
 * Create a new user based on informations from the Shibboleth handler if it's necessary or log in.
 *
 * If already authenticated - do nothing
 * If Shibboleth doesn't provide User information - error message
 * Else if user exists, and mail override (shib_auth_req_shib_only) enabled, override existing user info
 * If not exists, and Shibboleth provides mail address, create an account for this user
 * If there's no mail attribute, ask for the mail address on a generated form if mail override (shib_auth_req_shib_only) is disabled
 * In this case, the account will be created with this e-mail address.
 */
function shib_auth_init() {
  
  module_load_include('inc', 'shib_auth', 'forms');
  global $user;
  global $shib_auth_config;
  // Make sure that the user module is already loaded.
  drupal_load('module', 'user');
  
  $shib_auth_config = shib_auth_get_config();
  
	//If shib_auth_roles module is loaded, we will call debug function at the end of the role assignment
  if (!module_exists("shib_auth_roles")) shib_auth_debug();

  // the script is up here now from https://spaces.internet2.edu/display/SHIB2/isPassive, inserting to repo
  //TODO according to i2 ispassive page: are they ready?
  //In your Service Provider 2.x shibboleth.xml file, add redirectErrors="#THIS PAGE#" to the Error element.
  //Make sure #THIS PAGE# is protected with a lazy session (no Shibboleth session is enforced but attribute are made available to application in case a user has a session)
  //footer currently contains only ispassive script, if it was enabled
  
	shib_auth_footer();

  $consent_accepted = FALSE;
  
  // necessary variables: user identifier, email
  $uname = $_SERVER[$shib_auth_config['username_variable']];
  shib_auth_session_check($uname); // ensure that the current session belongs to this user
  $umail = $_SERVER[$shib_auth_config['email_variable']];
  $umail_single = preg_replace('/;.*/', '', $umail); // get the first one if there're many
  
  // Do nothing if there's no Shibboleth session
  if (!shib_auth_session_valid()) 
    return;
  
  // Do nothing if the user is logged in and we're not doing account linking
  if ($user->uid && !doing_account_linking())
    return; 
  
  // Do virtually nothing when we need to display the custom data form
  if ( isset($_SESSION['redirected_to_custom_data_form']) && $_SESSION['redirected_to_custom_data_form']) {
    unset($_SESSION['redirected_to_custom_data_form']); // Display it only once 
    return;
  }
  
  /********* Start the login/registering process **********/
  
  //check identifier if it exists, and not too long
  if(!shib_auth_check_identifier($uname)) {
    shib_auth_error('Shibboleth authentication process can\'t continue');
    return;
  } 
  //check if the old user exists in the shibboleth authmap 
  $existing_authmap = shib_auth_load_from_authmap($uname);
  
  //Check whether CONSENT VERSION is CHANGED, if so, users have to accept it again
  if ($_POST['form_id'] == 'shib_auth_custom_form' && $_POST['accept'])
	$consent_accepted = $_POST['accept'];
  //drupal_set_message("Old user, accept, consentver: ".(int)$existing_authmap.",".(int)$consent_accepted.",".(int)$existing_authmap['consentver'], 'error');

//*********** LOGIN EXISTING USER ***************      
  //The user exists in the authmap, and the consent version check is switched off, or she/he had accepted the newest consent version
  //Then let the user log in
  if ($existing_authmap && 
      (!$shib_auth_config['req_consent'] || ($existing_authmap['consentver']==$shib_auth_config['terms_ver']))) {
				  
    shib_login_authmap($uname, $umail_single, $existing_authmap['uid']);
  }
			  //The user exists in the authmap, and she had just accepted the new consent version
			  //Write the new version number into the her authmap row, and log her in
  else if ($existing_authmap && $consent_accepted ) { 
    shib_auth_consent_update($uname, $umail_single, $existing_authmap['uid']);
  }
//********* END OF LOGIN CASE *************

//********* REGISTER NEW USER *************
  //The user doesn't exists in the database, starting registering process
  else {
  //If it is account linking and the terms are accepted or forcing an existing user to accept termsandconditions

    //If we have an e-mail address from the shib server, and there isn't any user with this address, create an account with these infos
    if ($umail_single && !$shib_auth_config['override_email'] && !$shib_auth_config['override_username'] && 
	!$shib_auth_config['req_consent']) {       
	shib_auth_save_authmap($uname, $uname, $umail_single);
      }
      //if one of the customizing options enabled, ask for these values, then register her
      else if (shib_auth_custom_form($umail_single, $uname)) { 
					  //TODO
					  }
  else {
  shib_auth_error("E-mail address is missing. Please contact your site administrator!");}
  }
//********* END OF REGISTERING *************
} // function shib_auth_init()

/** 
 * Get Shibboleth handler base as an absolute URI (such as https://example.com/Shibboleth.sso)
 * @return handler base
 */
function shib_auth_get_handler_base() {
  /* can't use $shib_auth_config here because it is called from the config generating function */
  
  $handlerurl = variable_get('shib_auth_handler_url', '/Shibboleth.sso');
  $handlerprotocol = variable_get('shib_auth_handler_protocol', 'https');
  if (ereg("^http[s]{0,1}://", $handlerurl) ) {
    // If handlerurl is an absolute path
    return $handlerurl;
  }
  else {
    // Else, if the handlerurl is a relative path
    // If the URI doesn't start with slash then extend it
    if ( !ereg("^/", $handlerurl) ) $handlerurl = "/". $handlerurl;
    return $handlerprotocol ."://". $_SERVER['HTTP_HOST'] . $handlerurl;
  }

}
/**
 * Let the user exit from the Shibboleth authority when he/she log out from the actual Drupal site.
 * @param op What kind of action is being performed.
 * @param edit The array of form values submitted by the user.
 * @param account The user object on which the operation is being performed.
 * @param category The active category of user information being edited.
 */
function shib_auth_user($op, &$edit, &$account, $category = NULL) {
  global $base_url, $user, $shib_auth_config;
   if ($op == "logout") {
    $logouthandler = $shib_auth_config['full_logout_url'];
    unset($_SESSION['authentication']);
    $logout_redirect = $shib_auth_config['logout_return'];
    // If the logout_redirect URL was relative extension is needed.
    if (!ereg("^http[s]{0,1}://", $logout_redirect) ) {
      $logout_redirect = $base_url .'/'. $logout_redirect; // XXX url("<front>") kell helyette? XXX dupla / check
    // A: probably yes, the output will be the same, but we won't use the global variable
    }
    drupal_goto("$logouthandler?return=$logout_redirect");
  }
  else if ($op == "delete") {
    db_query("DELETE FROM {authmap} WHERE uid = %d AND authname = '%s' AND module = 'shib_auth'",
            $account->uid, $account->name);
     db_query("DELETE FROM {shib_authmap} WHERE uid = %d",
            $account->uid);
  }
} // function shib_auth_user(logout)

/**
 * Valid permissions for this module
 * @return array An array of valid permissions for the shib_auth module
 */

function shib_auth_perm() {
  return array('administer shibboleth authentication');
} // function shib_auth_perm()

//TODO: Document this function
function shib_auth_generate_login_url() {
  global $shib_auth_config;

  $sessioninitiator = $shib_auth_config['full_handler_url'];
  //Check whether clean url and i18 is enabled, and insert ?q=/ in the return url if not
  $url_prefix = '';
  if (!module_exists("i18n") && !variable_get('clean_url', FALSE)) {
    $url_prefix = '?q=/';
  }

  $forceauthn = '';
  if ($shib_auth_config['forceauthn'])
    $forceauthn = '&forceAuthn=1';

  $url_to_return = (isset($_SERVER['HTTPS'])||
                   ($shib_auth_config['shib_auth_force_https']&&substr($sessioninitiator,0,5)=='https') ?
                   'https' : 'http') 
                           .'://'. $_SERVER['HTTP_HOST']
                           . url('<front>')
                           . $url_prefix
                           .'/shib_login/'
                           . $_GET['q'];

  return "$sessioninitiator?target=" . urlencode($url_to_return) . $forceauthn;
}

/**
 * Generate the login text in HTML format using the 't' function
 * @param inform distinct login message whether it is in left block or in user/edit for account linking
 * @returns HTML text of the login form
 */
function generate_login_text($inform) {
//TODO: rename this function
  global $user;
  global $shib_auth_config;

  if (!$user->uid||$shib_auth_config['account_linking']) {
    
    $block_content = '';

    // If there is no session yet then we should put the login text into the block
    if (!$user->uid)
      $block_content  .= "<p><b><a href=\"" . shib_auth_generate_login_url() . "\">" 
		      . $shib_auth_config['auth_link_text']
		      . "</a></b></p>";
    //if uid is greater than 1 and user not yet authenticated with shib, display this message in user/edit
    else if ($inform && $_SESSION['authentication'] != 'shib_auth' && $user->uid > 1)
      $block_content  .= "<p><b><a href=\"$handler?target=". urlencode($url_to_return) . $forceauthn ."\">"
		      . t('Link this account to Shibboleth')
		      ."</a></b></p>";

    return $block_content;
  }
} // function generate_login_text()

/**
 * Generate the menu element to access the Shibboleth authentication module's administration page
 * @returns HTML text of the administer menu element
 */
function shib_auth_menu() {
  $items = array();

  $items['admin/user/shib_auth'] = array(
    'title'            => t('Shibboleth settings'),
    'description'      => t('Settings of the Shibboleth authentication module'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('shib_auth_admin_general'),
    'access arguments' => array('administer shibboleth authentication'),
    'file' => 'shib_auth_forms.inc',
  );

  $items['admin/user/shib_auth/general'] = array(
    'title'            => t('General settings'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer shibboleth authentication'),
    'weight'           => -10,
    'file' => 'shib_auth_forms.inc',
  );
  
  $items['shib_auth/get_custom_data'] = array(
    'title'            => t('Customize drupal user attributes'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('shib_auth_custom_form'),
    'access arguments' => array('access content'),
    'type'             => MENU_CALLBACK,
    'file' => 'shib_auth_forms.inc',
  );

   $items['shib_login/%'] = array(
    'page callback'    => 'shib_login',
    'type'             => MENU_CALLBACK,
    'access callback'  => 'access_shib_login',
    'file' => 'shib_auth_forms.inc',
  );

   $items['admin/user/shib_auth/advanced'] = array(
    'title'            => t('Advanced settings'),
    'type'             => MENU_LOCAL_TASK,
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('shib_auth_admin_advanced'),
    'access arguments' => array('administer shibboleth authentication'),
    'weight'           => -6,
    'file' => 'shib_auth_forms.inc',
  );

  return $items;
} // function shib_auth_menu()

/**
 * Generate the HTML text for the shib_auth login block
 * @param op the operation from the URL
 * @param delta offset
 * @returns block HTML
 */
function shib_auth_block($op='list', $delta=0, $edit = array()) {
  // listing of blocks, such as on the admin/block page
  switch ($op) {
    case "list":
      $blocks[0] = array(
        'info'       => t('Shibboleth authentication'),
        'status'     => TRUE,
        'visibility' => 1,
        'weight'     => 0,
        'region'     => 'left'
      );
      return $blocks;
    case 'configure':
      $form = array();
      switch ($delta) {
      case 0:
        $form['auth_link_text'] = array(
          '#type'          => 'textfield',
          '#title'         => t('Text of the auth link'),
          '#require'       => TRUE,
          '#size'          => 60,
          '#description'   => t('Here you can replace the text of the authentication link.'),
          '#default_value' => variable_get('auth_link_text', t('Shibboleth Login')),
        );
      }
      return $form;
    case 'save':
      switch ($delta) {
        case 0:
        variable_set('auth_link_text', $edit['auth_link_text']);
      }
      break;
    case "view": default:
      switch ($delta) {
        case 0:
          $block = array(
          'subject' => t('Shibboleth login'),
          'content' => generate_login_text(0) );
        break;
      }
      return $block;
  }
} // function shib_auth_block()

/**
 * Generate the administration form of the Shibboleth authentication module
 * @returns HTML text of the administration form
 */


/**
 * Alters user_login form for the shibboleth authentication module.
 *
 * @param $form The form.
 * @param $form_state contains all of the data of the form
 * @param $form_id The form ID.
 */
function shib_auth_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  if ($form_id == 'user_login') {
    $form['shibboleth'] = array(
      '#type' => 'hidden',
      '#weight' => -1,
      '#prefix' => generate_login_text(0),
      '#suffix' => '',
    );
  }
  if (($form_id == 'user_profile_form') && ($form['#parameters'][2]->uid == $user->uid)) {
    $form['shibboleth'] = array(
	'#type' => 'markup',
	'#weight' => -1,
	'#value' => generate_login_text(1),
	'#suffix' => '',
    );
  }
}

/**
 * Dummy access argument function
 */
function access_shib_login() {
//TODO: rename this function
  return TRUE;
}
