<?php
// $Id$
/**
 * @file
 * This is a Shibboleth authentication module.
 *
 * This module allow administrators to enable Shibboleth based authentication on their drupal installation.
 */

/**
 * We should insert some DISCLAIMER here, what do you think?
 */

//TODO: Document this function
function shib_auth_config($variable) {
  global $base_url;

  $var_store = array('account_linking' => FALSE,
                     'account_linking_text' => t('Link this account with Shibboleth.'),
                     'auto_destroy_session' => FALSE,
                     'debug_state' => FALSE,
                     'define_username' => FALSE,
                     'enable_custom_mail' => FALSE,
                     'forceauthn' => FALSE,
                     'force_https' => FALSE,
                     'auto_destroy_session' => FALSE,
                     'is_passive' => FALSE,
                     'terms_accept' => FALSE,
                     'debug_url' => '',
                     'terms_ver' => '',
                     'terms_url' => '/',
                     'wayf_uri' => '/DS',
                     'handler_protocol' => 'https',
                     'handler_url' => '/Shibboleth.sso',
                     'email_variable' => 'HTTP_SHIB_MAIL',
                     'username_variable' => 'REMOTE_USER',
                     'logout_url' => $base_url,
                     'link_text' => t('Shibboleth Login'),
                     'full_handler_url' => shib_auth_get_handler_base(). variable_get('wayf_uri','/DS'),
                     'full_logout_url' => shib_auth_get_handler_base() ."/Logout",
               );

  if (array_key_exists($variable, $var_store)) return variable_get("shib_auth_$variable", $var_store[$variable]);
  else {
    drupal_set_message('ERROR', "Here is some problem: function shib_auth_config($variable) called but $variable doesn't exists.");
    return FALSE;
  }
}

/**
 * This footer part executes isPassive script, if the option was checked on the configuration page
 */
function shib_auth_footer() {
  global $user;

  if (!shib_auth_session_valid() && shib_auth_config('is_passive') && !$user->uid) {
    $base = drupal_get_path('module', 'shib_auth');
    $my_settings = array( 'login_url' => shib_auth_generate_login_url());
    drupal_add_js(array('shib_auth' => $my_settings), "setting");
    drupal_add_js($base.'/isPassive.js','module','footer');
  }
}

/**
 * Display help and module information
 * @param path which path of the site we're displaying help
 * @param arg array that holds the current path as would be returned from arg() function
 * @return help text for the path
 */
function shib_auth_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/help#shib_auth':
      //TODO
      $output ='<p>'. t("The Shibboleth authentication module lets you utilize the advantages of the "
		    . "Single Sign On (SSO) methods.") .'</p>';
      $output .='<p>'. t("For more help related to Shibboleth and module configuration, see "
		     . "<a href=\"@wiki\">NIIF AAI wiki pages</a>.",
			array('@wiki' => url('https://wiki.aai.niif.hu/index.php/Drupal_Shibboleth_module'))) .'</p>';

      break;
    case 'admin/user/shib_auth':
      $output = '<p>'. t("The text shown in the block and on other login pages can be changed on the "
		     . "<a href=\"@block\">block settings page</a>.",
			array('@block' => url('admin/build/block/configure/shib_auth/0'))) .'</p>';
      break;
  }
  return $output;
} // function shib_auth_help

/** Errors out
  * Example usage:
  * 	if (something_bad_happens())
  *		return shib_auth_error("Something bad happened");
	* EXEPTION WORKAROUND for php4
  * A: I wouldn't use return, because there could be cases, when the error doesn't exists from function / statement
  *    This need to be checked though, because in other cases, it would delete an 'else'
  */
function shib_auth_error($msg = '') {
  drupal_set_message(t($msg) . t(' [Shibboleth authentication]'),'error');
  return FALSE;
}

function shib_auth_terminate_session() {
  global $user;
  // unset all session variables and destroy session
  if (isset($user->uid))
    sess_destroy_uid($user->uid);
  $_SESSION = array();
  session_destroy();
  $user = drupal_anonymous_user();
}

function shib_auth_session_check($uname) {
  global $user;
  // if the user IS logged in as non-admin, but we're missing Shibboleth identity
  if (!shib_auth_session_valid() && $_SESSION['authentication'] == 'shib_auth' &&
      shib_auth_config('auto_destroy_session') && $user->uid > 1) {
    shib_auth_error('Your session is expired. Please log in again');
    shib_auth_terminate_session();
  }
  if (isset($_SESSION['uname'])) {
    if ($_SESSION['uname'] != $uname) {
      /* XXX
	  This case another user was logged in using the same browser (and Drupal) session.
	  Probably we should try and re-register the user instead of just kicking him out,
	  but for now just terminate the session for safety.
	  This means that the new user has to initiate the session twice.
	  */
      shib_auth_terminate_session();
    }
  }
}

/**
 * Function to determine whether the called page is in the debug path
 * print_r-s $_SERVER if yes 
 */
function shib_auth_debug() {
  global $user;
  
  if (shib_auth_config('debug_state'))
    if (drupal_substr($_GET['q'], 0, drupal_strlen(shib_auth_config('debug_url'))) == shib_auth_config('debug_url')) {
      if ($user->uid) {
	$userinfo = array (
	  'uid' => $user->uid,
	  'name' => $user->name,
	  'mail' => $user->mail,
	  'roles' => $user->roles
	  );
	$debug_message = print_r ($userinfo, TRUE);
	drupal_set_message('<pre>'. $debug_message .'</pre>');
      }
      $debug_message = print_r($_SERVER, TRUE);
      drupal_set_message('<pre>'. $debug_message .'</pre>');
      
    }
}

function shib_auth_get_idp() {
  if (isset ($_SERVER['Shib-Identity-Provider']))
    return $_SERVER['Shib-Identity-Provider'];
  elseif (isset ($_SERVER['Shib_Identity_Provider']))
    return $_SERVER['Shib_Identity_Provider'];
  return $_SERVER['HTTP_SHIB_IDENTITY_PROVIDER'];
}

/**
 * Adds a record to {shib_authmap}
 *
 * @param $uid Drupal uid (number)
 * @param $federated_id federated identifier (max. 255 characters)
 * @param $consentver='' accepted terms&conditions version
 * @return FALSE on error, TRUE otherwise
 */
function shib_auth_add_authmap($uid,$federated_id,$consentver='') {
  // Check if $federated_id exists in {shib_authmap}
  $query_fed_id = db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $federated_id );
  if (db_fetch_object($query_fed_id)) {
    return shib_auth_error("Cannot link federated login to multiple accounts");
  }
  $sql="INSERT INTO {shib_authmap} (uid, targeted_id, idp, created, consentver) " 
      ."VALUES  ('%s', '%s', '%s', '%s', '%s')";
  return db_query($sql, $uid, $federated_id, shib_auth_get_idp(), date("Y-m-d H:i:s"), $consentver); 
}

/**
 * Checks whether Shibboleth SP has set the Identity Provider $_SERVER field. It is always set
 * if there is a Shibboleth SP session.
 * @return true if there is a valid Shibboleth session
 */
function shib_auth_session_valid() {
  return ((shib_auth_get_idp()));
}

/**
 * @return true if there is a valid Shibboleth session with a Shibboleth SP >= 2.0
 */
function shib_auth_session_isShib2x() {
  if (shib_auth_session_valid())
    return (isset($_SERVER['Shib-Identity-Provider']) || isset ($_SERVER['Shib_Identity_Provider']));
  return false;
}

/** 
 * Handle account linking
 * 
 * Saves an entry to {shib_authmap}, if the user is already logged in.
 * Mapping to default Drupal users (uid<=1) is not allowed.
 * @return TRUE if account linking is stored, FALSE otherwise
 */
function shib_auth_link_account ($federated_id,$consentver='') {
  global $user;
  
  // Assert some basic security requirements
  if (!$user) 
    return shib_auth_error("You must be logged in for account linking");
  if ($user->uid <= 1)
    return shib_auth_error("It is not allowed to link federated login to a system account");
  
  if (shib_auth_config('account_linking')) 
    return shib_auth_add_authmap($user->uid,$federated_id,$consentver);
  
  return FALSE;
}

/**
 * TODO: implement
 * Creates <b>new</b> Drupal user and saves user mapping to the shib_authmap table
 * 
 * It doesn't do any check on the input parameters except for asserting uniqueness
 * 
 * @param $fed_id federated user identifier
 * @param $uname custom username (might be equal to $uid)
 * @param $mail user email address (might be user defined)
 * @param $consentver accepted version of terms&conditions (acceptance must be checked before)
 * @return TRUE if saving user was successful, FALSE otherwise
 */
function shib_auth_user_register ($fed_id,$uname,$mail,$consentver='') {
  global $user;
  
  // Ensure that we have a valid shib session
  if (!shib_auth_session_valid())
    return shib_auth_error("Internal error while saving account: missing Shibboleth session");
  
  // XXX szerintem az ellenorzes nem kell ide.
  // A: AFAIR These are here to avoid logging in an existing user with the same name instead of the creating one (because of the use of login_register func)
  /*
  // Ensure that $uname is not in use
  if ( db_fetch_object( db_query("SELECT * FROM {users} WHERE name='%s'", $uname) ) ) 
    return shib_auth_error("Error saving user account, username is already in use.");
  
  // Ensure that $mail is not in use
  if ( db_fetch_object( db_query("SELECT * FROM {users} WHERE mail='%s'", $mail) ) ) 
    return shib_auth_error("Error saving user account, email address is already in use.");
  */
  $_SESSION['authentication'] = 'shib_auth';
  // Try to load user
  $user = user_load(array('name' => $uname));
  if (!isset($user->uid)) { // New user
    $user = user_external_login_register($uname, "shib_auth");
    $user = user_save($user, array('mail' => $mail));
    return shib_auth_save_authmap($fed_id,$user->uid,$consentver);
  }
  return TRUE;
}

/**
 * Saves an authmap entry to the database. Only checks the uniqueness of the federated id
 * @return TRUE if successful
 */
function shib_auth_authmap_save($fed_id,$uid,$consentver) {
  // Check $fed_id uniqueness
  if ( db_fetch_object( db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $fed_id) ) )
    return shib_auth_error("Internal error while saving user account: federated id is not unique.");
    
  // Grab $idp from the environment, set date
  if(!shib_auth_session_valid())
    return shib_auth_error("Internal error while saving account: missing Shibboleth session");
  // save user
  $sql = "INSERT INTO {shib_authmap} (uid, targeted_id, idp, created, consentver) VALUES  ('%s', '%s', '%s', '%s', '%s')";
  return db_query($sql,	$uid, $fed_id, shib_auth_get_idp(), date("Y-m-d H:i:s"), $consentver);
}

function shib_auth_authmap_get_user ($fed_id) {
  return ( db_fetch_object( db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $fed_id) ) );
}
/**
 * TODO: remove -- CAN BE REMOVED
 * XXX
 * refactor: shib_login_save_authmap -> shib_auth_register_user ???
 * Yes, we should merge these two functions into one, but these are not the same 
 * authmap_save is only for this module, while login_register is doing it in drupal.
 */
function shib_auth_save_authmap($uname, $custom_uname, $umail_single) {
  global $user;
  $email_already_used_query = db_query("SELECT * FROM {users} WHERE mail='%s'", $umail_single );
  $email_already_used = db_fetch_object($email_already_used_query);
  // If the mail address is used, give an error
  if ($email_already_used) {
    shib_auth_error("Error saving user account. E-mail address is already used.");
  }
  //else register the user with the given information
  else {
    //account linking: the user is already logged in
    if (!($user->uid > 1 && shib_auth_config('account_linking'))) {
      user_external_login_register($custom_uname, "shib_auth");
    }
    $_SESSION['authentication'] = 'shib_auth';
    $user = user_save($user, array('mail' => $umail_single));
    $idp = ($_SERVER['Shib-Identity-Provider']) ? 
      $_SERVER['Shib-Identity-Provider'] : $_SERVER['HTTP_SHIB_IDENTITY_PROVIDER'];
    $sql="INSERT INTO {shib_authmap} (uid, targeted_id, idp, created, consentver) VALUES  ('%s', '%s', '%s', '%s', '%s')";
    $result = db_query($sql, $user->uid, $uname, $idp, date("Y-m-d H:i:s"), shib_auth_config('terms_ver'));
  }
}

/**
 * TODO: remove
*/
function shib_login_authmap($uname, $umail_single, $uid) {
  global $user;
  $auth_map_un_query = db_query("SELECT name FROM {users} WHERE uid='%s'", $uid);
  $authmap_username = db_fetch_array($auth_map_un_query);
  user_external_login_register($authmap_username['name'], "shib_auth");
  $_SESSION['authentication'] = 'shib_auth';
  //and the Shibboleth mail address override was enabled in the admin config
  if (shib_auth_config('shib_auth_enable_custom_mail')==0) {
    //check if there isn't any user with this e-mail (whose name is different)
    $email_for_other_user_query =
      db_query("SELECT * FROM {users} WHERE mail='%s' AND name <> '%s'", $umail_single, $uname );
    $email_for_other_user = db_fetch_object($username_and_email_query);
    if ($email_for_other_user) {
      shib_auth_error("Error saving user account. E-mail address is already used.");
    }
    //if everything is allright, modify the mail address of the user.
    else {
      $user = user_save($user, array('mail' => $umail_single));
    }
  }
  if (isset($_SESSION['redirected_to_custom_data_form_url'])) {
    $redirect_url = $_SESSION['redirected_to_custom_data_form_url'];
    unset($_SESSION['redirected_to_custom_data_form_url']);
    drupal_goto($redirect_url);
  }
}

/** 
 * Check user identifier 
 * @return FALSE if the identifier is not valid
 */
function shib_auth_check_identifier($uname) {
  if (!$uname) {
        $message = t('Username is missing. Please contact your site administrator!');
        shib_auth_error($message);
        watchdog('shib_auth', $message, WATCHDOG_CRITICAL);
	return FALSE;
  } else if (drupal_strlen($uname)>255) {
        $message = t('User identifier is too long to process. Please contact your site administrator!');
        shib_auth_error($message);
        watchdog('shib_auth', $message, WATCHDOG_CRITICAL);
	return FALSE;
  }
	return TRUE;
}

/**
 * Load an authmap user object from shib_authmap
 * @return the authmap object(array) if found, null otherwise
 */
function shib_auth_load_from_authmap($uname) {
  $auth_map_query = db_query("SELECT * FROM {shib_authmap} WHERE targeted_id='%s'", $uname);
  return db_fetch_array($auth_map_query); 
}

function shib_auth_custom_mail($uname, $custom_username, $custom_mail) {
  if (!valid_email_address($custom_mail)) shib_auth_error("Please enter a valid e-mail address");
	  // if custom username not enabled
	  else if (shib_auth_config('define_username')==0)  {
	    // and email isn't used by another registered drupal user
	      shib_auth_save_authmap($uname, $uname, $custom_mail);
	  }
	    //if the username is also enabled
	  else if ((shib_auth_config('define_username')==1) && isset($custom_username) && $custom_username) {
	    if ($error = user_validate_name($custom_username)) 
		shib_auth_error($error);
	    else {
	      // and it isn't used by another registered drupal user
	      $un_already_used_query = db_query("SELECT * FROM {users} WHERE name='%s'", $custom_username);
	      $un_already_used = db_fetch_object($un_already_used_query);
	      if ($un_already_used) {
		shib_auth_error("Error saving user account. User name is already used.");
	      }
		  //register the user with the given address, and the shib provided username
	      else {
		    shib_auth_save_authmap($uname, $custom_username, $custom_mail);
	      }
	    }
	  }
	// If the consent config enabled and it isn't accepted
}

function shib_auth_custom_username($uname, $custom_username, $umail_single) {
	  //validate it
	  if ($error = user_validate_name($custom_username)) shib_auth_error($error);
	  else {
	    $un_already_used_query = db_query("SELECT * FROM {users} WHERE name='%s'", $custom_username);
	    $un_already_used = db_fetch_object($un_already_used_query);
	    if ($un_already_used) {
	      shib_auth_error("Error saving user account. User name is already used.");
	    }
		  //register the user with the given username, and the shib provided e-mail address
	    else {
	    shib_auth_save_authmap($uname, $custom_username, $umail_single);
	    }
	  }
}
/**
 * If any customization or consent option is checked, the custom form will show up before registering.
 * 
 */
function shib_auth_custom_form($umail_single = NULL, $uname = NULL) {
  if (shib_auth_config('enable_custom_mail') ||
    ($umail_single && shib_auth_config('define_username')) ||
      shib_auth_config('terms_accept')) {
      // if custom something was enabled on the admin form, save it as a variable
      if ($_POST['form_id'] == 'shib_auth_custom_data') {
	if ($_POST['custom_mail'])	$custom_mail = $_POST['custom_mail'];
	if ($_POST['custom_username']) 	$custom_username = $_POST['custom_username'];
	if ($_POST['accept'])           $consent_accepted = $_POST['accept'];
      }

       
	//If the consent is accepted or it isn't configured
	if (($consent_accepted && shib_auth_config('terms_accept')) ||
	  !shib_auth_config('terms_accept')) {
// ****** CUSTOM MAIL **********
      //if the user provided the custom mail string on the custom data form, and it is not empty
	    if (isset($custom_mail) && $custom_mail)
	      shib_auth_custom_mail($uname, $custom_username, $custom_mail);
// ****** CUSTOM USERNAME **********
	    //if there is no custom email option, but the user can define custom username
	    else if (shib_auth_config('define_username') && isset($custom_username) && $custom_username)
	      shib_auth_custom_username($uname, $custom_username, $umail_single);
	    else if ($consent_accepted && shib_auth_config('terms_accept'))
	    shib_auth_save_authmap($uname, $uname, $umail_single);
	    // ****** USER CONSENT ********** 
	    
	  }
	  else if ($_GET['q']!='shib_auth/get_custom_data') {
	    $_SESSION['redirected_to_custom_data_form'] = TRUE;
	    $_SESSION['redirected_to_custom_data_form_url'] = $_GET['q'];
	    drupal_goto('shib_auth/get_custom_data'); 
	  } 


	  
      

  // ****** SHOW FORM, AND REDIRECT ********
  //We want to show the custom mail input form, and then redirect the user to the node, he wanted to go

    //then the user is redirected to the page, which she wanted to open before the auth process had been initiatedd
    if (isset($_SESSION['redirected_to_custom_data_form_url'])) {
      $redirect_url = $_SESSION['redirected_to_custom_data_form_url'];
      unset($_SESSION['redirected_to_custom_data_form_url']);
      drupal_goto($redirect_url); 
    }
  }
}

function doing_account_linking() {
//TODO: rename this function
  if (shib_auth_config('account_linking'))
    return (strstr($_GET['q'],"shib_login") || strstr($_GET['q'],"shib_auth_custom_data"));
  return FALSE;
}

function shib_auth_consent_update($uname, $umail_single, $uid) {
	$sql="UPDATE {shib_authmap} SET consentver='%s' WHERE targeted_id='%s'";
  $result = db_query($sql, shib_auth_config('terms_ver'), $uname);
  shib_login_authmap($uname, $umail_single, $uid);
}
/**
 * Create a new user based on informations from the Shibboleth handler if it's necessary or log in.
 *
 * If already authenticated - do nothing
 * If Shibboleth doesn't provide User information - error message
 * Else if user exists, and mail override (shib_auth_req_shib_only) enabled, override existing user info
 * If not exists, and Shibboleth provides mail address, create an account for this user
 * If there's no mail attribute, ask for the mail address on a generated form if mail override (shib_auth_req_shib_only) is disabled
 * In this case, the account will be created with this e-mail address.
 */
function shib_auth_init() {

  module_load_include('inc', 'shib_auth', 'forms');
  global $user;
  // Make sure that the user module is already loaded.
  drupal_load('module', 'user');

  //If shib_auth_roles module is loaded, we will call debug function at the end of the role assignment
  if (!module_exists("shib_auth_roles")) shib_auth_debug();

  // the script is up here now from https://spaces.internet2.edu/display/SHIB2/isPassive, inserting to repo
  //TODO according to i2 ispassive page: are they ready?
  //In your Service Provider 2.x shibboleth.xml file, add redirectErrors="#THIS PAGE#" to the Error element.
  //Make sure #THIS PAGE# is protected with a lazy session (no Shibboleth session is enforced but attribute are made available to application in case a user has a session)
  //footer currently contains only ispassive script, if it was enabled

  //TODO: Why is this function calling here? Isn't this function the implementation of hook_footer?
  #shib_auth_footer();

  $consent_accepted = FALSE;

  // necessary variables: user identifier, email
  $uname = $_SERVER[shib_auth_config('username_variable')];
  shib_auth_session_check($uname); // ensure that the current session belongs to this user
  $umail = $_SERVER[shib_auth_config('email_variable')];
  $umail_single = preg_replace('/;.*/', '', $umail); // get the first one if there're many
  
  // Do nothing if there's no Shibboleth session
  if (!shib_auth_session_valid()) 
    return;
  
  // Do nothing if the user is logged in and we're not doing account linking
  if ($user->uid && !doing_account_linking())
    return; 
  
  // Do virtually nothing when we need to display the custom data form
  if ( isset($_SESSION['redirected_to_custom_data_form']) && $_SESSION['redirected_to_custom_data_form']) {
    unset($_SESSION['redirected_to_custom_data_form']); // Display it only once 
    return;
  }
  
  /********* Start the login/registering process **********/
  
  //check identifier if it exists, and not too long
  if(!shib_auth_check_identifier($uname)) {
    shib_auth_error('Shibboleth authentication process can\'t continue');
    return;
  } 
  //check if the old user exists in the shibboleth authmap 
  $existing_authmap = shib_auth_load_from_authmap($uname);
  
  //Check whether CONSENT VERSION is CHANGED, if so, users have to accept it again
  if ($_POST['form_id'] == 'shib_auth_custom_data' && $_POST['accept'])
    $consent_accepted = $_POST['accept'];
  //drupal_set_message("Old user, accept, consentver: ".(int)$existing_authmap.",".(int)$consent_accepted.",".(int)$existing_authmap['consentver'], 'error');

//*********** LOGIN EXISTING USER ***************      
  //The user exists in the authmap, and the consent version check is switched off, or she/he had accepted the newest consent version
  //Then let the user log in
  if ($existing_authmap && 
      (!shib_auth_config('terms_accept') || ($existing_authmap['consentver']==shib_auth_config('terms_ver')))) {
    shib_login_authmap($uname, $umail_single, $existing_authmap['uid']);
  }
			  //The user exists in the authmap, and she had just accepted the new consent version
			  //Write the new version number into the her authmap row, and log her in
  else if ($existing_authmap && $consent_accepted ) { 
    shib_auth_consent_update($uname, $umail_single, $existing_authmap['uid']);
  }
//********* END OF LOGIN CASE *************

//********* REGISTER NEW USER *************
  //The user doesn't exists in the database, starting registering process
  else {
  //If it is account linking and the terms are accepted or forcing an existing user to accept termsandconditions

    //If we have an e-mail address from the shib server, and there isn't any user with this address, create an account with these infos
    if ($umail_single && !shib_auth_config('enable_custom_mail') && !shib_auth_config('define_username') && 
	!shib_auth_config('req_consent')) {       
	shib_auth_save_authmap($uname, $uname, $umail_single);
    }
//********* CUSTOM OPTION ENABLED **********
    //Lock user into the customization / consent form, unless it is the terms and contitions page itself
    else if (('/'.$_GET['q']) == shib_auth_config('terms_url')) {
    }
    //if one of the customizing options enabled, ask for these values, then register her
    else if (shib_auth_custom_form($umail_single, $uname)) {
    }
    //If there is no custom mail option enabled, and we didn't received email address from server, output an error
    else {
    shib_auth_error("E-mail address is missing. Please contact your site administrator!");
    }
  }
//********* END OF REGISTERING *************
} // function shib_auth_init()

/** 
 * Get Shibboleth handler base as an absolute URI (such as https://example.com/Shibboleth.sso)
 * @return handler base
 */
function shib_auth_get_handler_base() {
  $handlerurl = variable_get('handler_url','/Shibboleth.sso');
  $handlerprotocol = variable_get('handler_protocol','https');
  if (ereg("^http[s]{0,1}://", $handlerurl) ) {
    // If handlerurl is an absolute path
    return $handlerurl;
  }
  else {
    // Else, if the handlerurl is a relative path
    // If the URI doesn't start with slash then extend it
    if ( !ereg("^/", $handlerurl) ) $handlerurl = "/". $handlerurl;
    return $handlerprotocol ."://". $_SERVER['HTTP_HOST'] . $handlerurl;
  }

}
/**
 * Let the user exit from the Shibboleth authority when he/she log out from the actual Drupal site.
 * @param op What kind of action is being performed.
 * @param edit The array of form values submitted by the user.
 * @param account The user object on which the operation is being performed.
 * @param category The active category of user information being edited.
 */
function shib_auth_user($op, &$edit, &$account, $category = NULL) {
  global $base_url, $user;
   if ($op == "logout") {
    $logouthandler = shib_auth_config('full_logout_url');
    unset($_SESSION['authentication']);
    $logout_redirect = shib_auth_config('logout_url');
    // If the logout_redirect URL was relative extension is needed.
    if (!ereg("^http[s]{0,1}://", $logout_redirect) ) {
      $logout_redirect = $base_url .'/'. $logout_redirect; // XXX url("<front>") kell helyette? XXX dupla / check
    // A: probably yes, the output will be the same, but we won't use the global variable
    }
    drupal_goto("$logouthandler?return=$logout_redirect");
  }
  else if ($op == "delete") {
    db_query("DELETE FROM {authmap} WHERE uid = %d AND authname = '%s' AND module = 'shib_auth'",
            $account->uid, $account->name);
     db_query("DELETE FROM {shib_authmap} WHERE uid = %d",
            $account->uid);
  }
} // function shib_auth_user(logout)

/**
 * Valid permissions for this module
 * @return array An array of valid permissions for the shib_auth module
 */

function shib_auth_perm() {
  return array('administer shibboleth authentication');
} // function shib_auth_perm()

//TODO: Document this function
function shib_auth_generate_login_url() {

  $sessioninitiator = shib_auth_config('full_handler_url');
  $forceauthn = '';

  if (shib_auth_config('forceauthn'))
    $forceauthn = '&forceAuthn=1';

  $url_to_return = (isset($_SERVER['HTTPS'])||
                   (shib_auth_config('force_https') && substr($sessioninitiator, 0, 5) == 'https') ?
                   'https' : 'http')
                           .'://'. $_SERVER['HTTP_HOST']
                           . url('shib_login/')
                           . $_GET['q'];

  return "$sessioninitiator?target=" . urlencode($url_to_return) . $forceauthn;
}

/**
 * Generate the menu element to access the Shibboleth authentication module's administration page
 * @returns HTML text of the administer menu element
 */
function shib_auth_menu() {
  $items = array();

  $items['admin/user/shib_auth'] = array(
    'title'            => t('Shibboleth settings'),
    'description'      => t('Settings of the Shibboleth authentication module'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('shib_auth_admin_general'),
    'access arguments' => array('administer shibboleth authentication'),
    'file' => 'shib_auth_forms.inc',
  );

  $items['admin/user/shib_auth/general'] = array(
    'title'            => t('General settings'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer shibboleth authentication'),
    'weight'           => -10,
    'file' => 'shib_auth_forms.inc',
  );
  
  $items['shib_auth/get_custom_data'] = array(
    'title'            => t('Customize drupal user attributes'),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('shib_auth_custom_data'),
    'access arguments' => array('access content'),
    'type'             => MENU_CALLBACK,
    'file' => 'shib_auth_forms.inc',
  );

   $items['shib_login/%'] = array(
    'page callback'    => 'shib_login',
    'type'             => MENU_CALLBACK,
    'access callback'  => 'access_shib_login',
    'file' => 'shib_auth_forms.inc',
  );

   $items['admin/user/shib_auth/advanced'] = array(
    'title'            => t('Advanced settings'),
    'type'             => MENU_LOCAL_TASK,
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('shib_auth_admin_advanced'),
    'access arguments' => array('administer shibboleth authentication'),
    'weight'           => -6,
    'file' => 'shib_auth_forms.inc',
  );

  return $items;
} // function shib_auth_menu()

/**
 * Generate the HTML text for the shib_auth login block
 * @param op the operation from the URL
 * @param delta offset
 * @returns block HTML
 */
function shib_auth_block($op='list', $delta=0, $edit = array()) {
  // listing of blocks, such as on the admin/block page
  switch ($op) {
    case "list":
      $blocks[0] = array(
        'info'       => t('Shibboleth authentication'),
        'status'     => TRUE,
        'visibility' => 1,
        'weight'     => 0,
        'region'     => 'left'
      );
      return $blocks;
    case 'configure':
      $form = array();
      switch ($delta) {
      case 0:
        $form['shib_auth_link_text'] = array(
          '#type'          => 'textfield',
          '#title'         => t('Text of the auth link'),
          '#require'       => TRUE,
          '#size'          => 60,
          '#description'   => t('Here you can replace the text of the authentication link.'),
          '#default_value' => shib_auth_config('link_text'),
        );
      }
      return $form;
    case 'save':
      switch ($delta) {
        case 0:
        variable_set('shib_auth_link_text', $edit['shib_auth_link_text']);
      }
      break;
    case "view": default:
      switch ($delta) {
        case 0:
          $block = array(
            'subject' => t('Shibboleth login'),
            'content' =>  _login_url_html(),
          );
        break;
      }
      return $block;
  }
} // function shib_auth_block()

/**
 * Generate the login block content if user not logged in
 *
 */
function _login_url_html($is_account_linking = FALSE) {
  global $user;

  //add theme css
  drupal_add_css(drupal_get_path('module', 'shib_auth') .'/shib_auth.css');

  if ($user->uid === 0 AND $is_account_linking === FALSE) {
    return theme('shib_login_block', shib_auth_generate_login_url(), shib_auth_config('link_text'));
  }
  elseif ($_SESSION['authentication'] !== 'shib_auth' AND $user->uid > 1 AND $is_account_linking) {
    return theme('shib_login_block', shib_auth_generate_login_url(), shib_auth_config('account_linking_text'));
  }
  return NULL;
}

/**
 * Generate the administration form of the Shibboleth authentication module
 * @returns HTML text of the administration form
 */


/**
 * Alters user_login form for the shibboleth authentication module.
 *
 * @param $form The form.
 * @param $form_state contains all of the data of the form
 * @param $form_id The form ID.
 */
function shib_auth_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  if ($form_id == 'user_login') {
    $form['shibboleth'] = array(
      '#type' => 'markup',
      '#weight' => -20,
      '#value' => _login_url_html(),
    );
  }
  if (($form_id == 'user_profile_form') && ($form['#parameters'][2]->uid == $user->uid)) {
    $form['shibboleth'] = array(
      '#type' => 'markup',
      '#weight' => -1,
      '#value' => _login_url_html(TRUE),
    );
  }
}

/**
 * Dummy access argument function
 */
function access_shib_login() {
//TODO: rename this function
  return TRUE;
}

/**
 * Implement of the hook_theme()
 */
function shib_auth_theme($existsing, $type, $theme, $path) {
  return array(
    'shib_login_block' => array(
      'template' => 'shib_login_block',
      'arguments' => array(
        'login_url'  => NULL,
        'login_text' => NULL,
      ),
    ),
  );
}
